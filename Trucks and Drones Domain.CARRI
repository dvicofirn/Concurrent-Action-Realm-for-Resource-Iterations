Start Domain:
Entities:
#Entities and their related origin. If type of entity has no origin, will not have brackets.
Location (Location), Drone (Vehicle), Truck (Vehicle), Package (Package), Request (Request)
End Entities

Variables:
#Right now no use for entity in brackets
const locType INT (Location) #Related to Location entity, is constant therefore tuple, and expected having #integers
const locAdj MULTY (Location) #Have Set - meaning tuple of Sets. Sets will have integers.
## var locCap INT (Location) Will not use this variable for now 

var droneLoc INT (Drone) #Variable, meaning it is a list
var droneCap INT (Drone)
var droneCharge INT (Drone)
var droneBoard BOOL (Drone) # Could also be INT of 0 and 1

var truckLoc INT (Truck)
var truckDroneCap INT (Truck)
var truckPackCap INT (Truck)

items package var: type INT, loc INT, onEntity INT (Package)
# Dictionary of lists, each list has 3 integers (Later will give example how interpreted)
items request const: type INT, loc INT, urgency INT (Request)
#Dictionary of tuples. Despite urgency is changing, because it only changes between iterations, it will be #considered const.

End Variables

#Actions have 4 fields:
#Precs - preconditions that are aren't possibly conflicting
#Confs - preconditions that other entities can (create conflict) 
#Effects - Effects on variables
#Cost - cost of action
#In reality I plan on Implementing base Wait, Travel, Pick & Deliver
#If not using .Add it overrides implementation.

Actions:
DroneWait: id - Drone (Wait) #Action name, var related to acting entity, other required vars, inheriting action
Precs:
droneCharge id  > 0
droneBoard id = false
Effects:
droneCharge id  : droneCharge id - 1
Cost:
1
End Action

DroneTravel: id - Drone, to - Location (Travel) 
Precs:
	locAdj (droneLoc id) ? to # In this case because locAdj is tuple of sets, it should do 'is to in locAdj[from]'
	not (locType to = 2)
	droneCharge id > 0
	droneBoard id = false
Effects:
	droneCharge id  : droneCharge id - 1
	droneLoc id : to
Cost:
1
End Action

DronePick: id - Drone, pack - Package (Pick)
Precs:
	droneCharge id > 0
	droneBoard id = false 
	droneLoc id = package loc pack
	droneCap id < 1
Confs:
	packge onEntity pack = 0
Effects:
	droneCap id : 0
	droneCharge id  : droneCharge id - 1
	package loc pack : id
	package onEntity pack : 1
Cost:
1
End Action

DroneDeliver: id - Drone, pack - Package, req - Request (Deliver)
Precs:
	droneCharge id > 0
	droneBoard id = false
	droneLoc id = request loc req
	package onEntity pack = 1
	package loc pack = droneLoc id
	package type pack = request type req
Confs:
	request exists req # Check if request still exists (Did other drone delivered ?)
Effects:
	droneCap id : 1
	droneCharge id  : droneCharge id - 1
	package remove : pack
	request remove : req
Cost:
1
End Action

DroneEmergencyCharge: id - Drone
Precs:
droneCharge id = 0
droneBoard id = false
Confs:
droneCharge id : 10
Cost:
40
End Action

DroneBoard: id - Drone, trk - Truck
Precs:
((droneLoc id = truckLoc trk) and (droneBoard id = false) or ((droneLoc id = trk) and (droneBoard = true))
Confs:
truckDroneCap trk < 4
(truckPackCap < 8) or (droneCap id = 0) #In case of overloading packs, using or so it won't matter for drone with no packs 
Effects:
droneLoc id : trk
droneBoard id = true
Case (droneCharge id < 8):
droneCharge id : droneCharge id + 3
Else:
droneCharge id : 10
End Case
Case (droneCap id = 1):
All(pack - Package) ((package onEntity pack = 1) and (package loc pack = id)):
package onEntity pack : 2
package loc pack : trk
End All
End Case
Cost:
2
End Action

DroneExitBoard: id - Drone, trk - Truck
Precs:
droneBoard id : true
droneLoc id = trk
not (locType(truckLoc trk) = 2)
Effects:
droneLoc id : truckLoc trk
droneBoard id : false
Cost:
1
End Action

DroneExitBoardWithPack: id - Drone, trk - Truck, pack - Package (DroneExitBoard) #This is an example of addition to existing action
Precs.Add:
	package loc pack: trk
Confs: #Could also implement as Confs.Add
	package onEntity pack = 2 #Other drone might want to take it. It's fine to not re check package location
	Effects.Add:
	package onEntity pack : 1
	package loc pack : id
End Action

TruckWait: id - Truck (Wait)
End Action
#Action with no pre conditions or costs. Default cost is 0.

TruckTravel: id - Truck, to - Location (Travel)
Precs:
locAdj (truckLoc id) ? to
not (locType to = 1)
Effects:
truckLoc id : to
Cost:
1
End Action

TruckTurbo: id - Truck, to - Location, through - Location (TruckTravel) #Here using TruckTravel's Effcts
Precs:
locAdj (truckLoc id) ? through
locAdj through ? to
not (locAdj (truckLoc id) ? to)
not (locType to = 1)
not (locType through = 1)
Cost:
3
End Action
End Actions

EnvSteps:
#Should be like actions, except it's kinda different. Didn't think of fitting implementation yet.
Urgency: 
Cost:
NewVal c : 0
All (req - Request): #Fancy way to say "for req in request"
c : c + 5
c : c + (request urgency req) * 5 #Could be c + (request urgency req *5) + 5 if possible
End All
c
End EnvStep

End EnvSteps

# There is only one IterStep per Domain. Addition of new packs and requests is automatic so not refered to.
IterStep:
All (req - Request):
Case (request urgency req < 3):
Replace request req: #Some fancy way to replace the whole tuple...
request type req, request loc req, request urgency req + 1
#If it's too complicated, I'm fine with request urgency req: request urgency req +1
#And making items request var
End Replace
End Case
End All
End IterStep

End Domain

#From now on this is comments#
Example how variables should look like:
const locType INT (Location) = (0, 1, 0, 2, 0, 0,...)
const locAdj MULTY (Location)  = ({1,3}, {0,2}, {4,5,8}, {}, {10}, ...)
var droneLoc INT (Drone) = (1, 5, 8, 2,...)
var droneBoard BOOL (Drone) = (False, False, True, False, ...)
items package var: type INT, loc INT, onEntity INT (Package) =
{0: [1, 2, 0], 1: [2, 4, 1], 3: [0, 0, 0], ...}
items request const: type INT, loc INT, urgency INT (Request) =
{ 0: (2, 5, 0), 2: (0, 10, 0), 3: (1, 0, 1), ... }
